package main

import (
	"bufio"
	"fmt"
	"go/ast"
	"go/token"
	"log"
	"os"
	"regexp"
	"strings"
)

type ReplaceConfig struct {
	File        FileConf
	Start       int
	End         int
	CurrentType string
	CurrentVar  string
	ReplaceType string
}

func ScanFunction(config ReplaceConfig) {
	lines := ReadFileLines(config.File.Filename, config.Start, config.End)
	line := ReplaceFuncType(lines, config)
	WriteResultToFile(line)
}

func ReadFileLines(filename string, start int, end int) []string {
	f, err := os.Open(filename)
	if err != nil {
		log.Println("err", err)
	}
	scanner := bufio.NewScanner(f)
	var lines []string
	lineNumber := 1
	for scanner.Scan() {
		line := scanner.Text()
		if lineNumber >= start && lineNumber <= end {
			lines = append(lines, line)
		}
		lineNumber++
	}
	return lines
}

func ReplaceFuncType(lines []string, config ReplaceConfig) string {
	file := strings.Join(lines, "\n")
	fmt.Println("Func is -> \n", file)
	replacements := map[string]string{
		config.CurrentType: config.ReplaceType,
		config.CurrentVar:  strings.ToLower(config.ReplaceType),
	}

	for key, value := range replacements {
		r := regexp.MustCompile(`[ ()";.{}\n\t]` + key + `[ ()";.{}\n\t]`)
		r2 := regexp.MustCompile(key)

		file = r.ReplaceAllStringFunc(file, func(match string) string {
			return r2.ReplaceAllString(match, value)
		})
	}

	return file
}

func WriteResultToFile(line string) {
	f, err := os.Create(strings.Replace(Conf.File.Filename, ".go", "_lazygen.go", 1))
	if err != nil {
		log.Println(err)
	}
	defer f.Close()
	f.Write([]byte("// ATTENTION! THIS FILE WAS GENERATED BY LAZYGEN\n"))
	f.Write([]byte("// DONT TOUCH IT...\n"))
	f.Write([]byte("package " + Conf.Package + "\n"))
	f.Write([]byte("\n"))
	f.Write([]byte(line))
}

type CommentConf struct {
	Text     string
	Filename string
	Pos      int
}

func CheckCommentParams(comment string) (bool, []string) {
	// find one param
	r := regexp.MustCompile(`-type=(\w+)`)
	// todo find aray params like -type="Note, Model, Some"
	matches := r.FindStringSubmatch(comment)
	if len(matches) > 1 {
		param := matches[len(matches)-1]
		return true, []string{param}
	}
	return false, nil
}

func FindValidFunction(fs *token.FileSet, comment *ast.Comment) (bool, token.Position) {
	r := regexp.MustCompile("lazygen")
	if r.Match([]byte(comment.Text)) {
		return true, fs.Position(comment.Pos())
	}
	return false, token.Position{}
}

func FindFunctionParams(node *ast.FuncDecl) (bool, string, string) {
	var currentType, currentVar string
	if node.Recv != nil {
		list := node.Recv.List
		if list != nil && len(list) > 0 {
			for _, rec := range list {
				currentVar = rec.Names[0].Name
				currentType = rec.Type.(*ast.Ident).Name
			}
			return true, currentVar, currentType
		}
	}
	return false, "", ""
}
